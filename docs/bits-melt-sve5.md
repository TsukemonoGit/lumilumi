# UI ライブラリ移行分析報告書：melt-ui vs bits-ui

## 1. エグゼクティブサマリー

**結論：`@melt-ui/svelte` (Svelte 4/Action 版) を継続採用。**
Svelte 5 プロジェクトにおいて、最新版（next-gen）や bits-ui への移行を検証したが、タイムライン（TL）における大量のコンポーネントマウント（50 件以上）時に致命的なパフォーマンス低下を確認。現在は「書きやすさ」よりも「描画パフォーマンス」を優先し、Action ベースの設計を維持する。

## 2. 比較検証結果

| 比較項目              | melt-ui (Sve4)     | bits-ui (Sve5)          | melt-ui (Sve5/next)     |
| --------------------- | ------------------ | ----------------------- | ----------------------- |
| **設計思想**          | **Action ベース**  | Component ベース        | Class / Spread ベース   |
| **初期化コスト**      | **低 (On-demand)** | 高 (Mount 時)           | 中 (Spread 評価時)      |
| **DOM 構造**          | フラット           | 階層的・複雑            | フラット                |
| **50 件表示時の挙動** | 高速・安定         | **実用不可 (描画遅延)** | 僅かに重い (再評価負荷) |
| **推奨度**            | ⭐⭐⭐⭐⭐         | ⭐                      | ⭐⭐⭐                  |

## 3. 判明したボトルネックの詳細

### A. スプレッド構文 (`{...props}`) の再評価コスト

Svelte 5 版の Melt UI や Bits UI が採用しているスプレッド構文は、オブジェクトのプロパティ（ARIA 属性等）が 1 つでも更新されると、DOM 属性全体を再チェックする挙動がある。

- **ソース:** [Svelte GitHub Issue #12601](https://github.com/sveltejs/svelte/issues/12601) にて、ライブラリ作者の Hunta 氏もこの再評価コストを認識済み。

### B. コンポーネント・オーバーヘッドの累積

`bits-ui` 等のコンポーネントベースのライブラリでは、1 ノートあたり複数の Root コンポーネント（Dialog, Popover, Dropdown）が生成される。

- 50 ノート × 4 コンポーネント = **200 個以上のコンポーネントインスタンス**が `$effect` や Portal 管理を実行し、メインスレッドをブロッキングする。
- `forceMount` 属性の使用により、非表示要素まで初期化が走ることで負荷が倍増した。

## 4. 今後の移行・再検討の基準

以下のいずれかの条件を満たした場合にのみ、構成の変更を検討する。

1. **Svelte フレームワーク側の最適化**

- スプレッド構文の属性更新が、Action 方式と同等のコストまで削減された場合。

2. **アプリケーション設計の変更**

- 各ノートにインスタンスを持たせず、アプリケーション全体で「単一の Dialog/Popover」を使い回すシングルトン設計へリファクタリングが完了した場合。

3. **melt-ui (@melt-ui/svelte) のメンテナンス終了**

- セキュリティリスクや Svelte 6 以降の非互換性が発生した場合。

## 5. 補足

本分析は 2026-01-12 時点のライブラリ仕様に基づいています。検証用ブランチ `bits-ui` は、上記理由によりマージせずクローズします。
